import { TwingContext } from "./context";
import { TwingEnvironment } from "./environment";
import { TwingOutputBuffer } from "./output-buffer";
import { TwingSourceMapRuntime } from "./source-map-runtime";
import { TwingTemplateNode } from "./node/template";
import { TwingMarkup } from "./markup";
import { TwingSource } from "./source";
import { TwingFilter } from "./filter";
import { TwingFunction } from "./function";
import { TwingTest } from "./test";
import { TwingEscapingStrategy } from "./escaping-strategy";
export type TwingTemplateBlockMap = Map<string, [TwingTemplate, string]>;
export type TwingTemplateBlockHandler = (context: TwingContext<any, any>, outputBuffer: TwingOutputBuffer, blocks: TwingTemplateBlockMap, sandboxed: boolean, sourceMapRuntime?: TwingSourceMapRuntime) => Promise<void>;
export type TwingTemplateMacroHandler = (outputBuffer: TwingOutputBuffer, sandboxed: boolean, sourceMapRuntime: TwingSourceMapRuntime | undefined, ...macroArguments: Array<any>) => Promise<TwingMarkup>;
export type TwingTemplateAliases = TwingContext<string, TwingTemplate>;
export interface TwingTemplate {
    readonly aliases: TwingTemplateAliases;
    readonly blockHandlers: Map<string, TwingTemplateBlockHandler>;
    readonly canBeUsedAsATrait: boolean;
    readonly source: TwingSource;
    readonly macroHandlers: Map<string, TwingTemplateMacroHandler>;
    readonly name: string;
    /**
     * @param candidate
     * @param method
     *
     * @throws {@link TwingSandboxSecurityNotAllowedMethodError} When the method of the passed candidate is not allowed to be executed
     */
    checkMethodAllowed(candidate: any | TwingMarkup, method: string): void;
    /**
     * @param candidate
     * @param property
     *
     * @throws {@link TwingSandboxSecurityNotAllowedPropertyError} When the property of the passed candidate is not allowed to be accessed
     */
    checkPropertyAllowed(candidate: any | TwingMarkup, property: string): void;
    checkSecurity(tags: Array<string>, filters: Array<string>, functions: Array<string>): void;
    createTemplateFromString(content: string, name: string | null): Promise<TwingTemplate>;
    displayBlock(name: string, context: TwingContext<any, any>, outputBuffer: TwingOutputBuffer, blocks: TwingTemplateBlockMap, useBlocks: boolean, sandboxed: boolean, sourceMapRuntime?: TwingSourceMapRuntime): Promise<void>;
    escape(value: string | boolean | TwingMarkup | null | undefined, strategy: TwingEscapingStrategy | string, charset: string | null, autoEscape?: boolean): Promise<string | boolean | TwingMarkup>;
    execute(context: TwingContext<any, any>, outputBuffer: TwingOutputBuffer, childBlocks: TwingTemplateBlockMap, options?: {
        sandboxed?: boolean;
        sourceMapRuntime?: TwingSourceMapRuntime;
    }): Promise<void>;
    getBlocks(): Promise<TwingTemplateBlockMap>;
    getFilter(name: string): TwingFilter | null;
    getFunction(name: string): TwingFunction | null;
    getParent(context: TwingContext<any, any>, outputBuffer: TwingOutputBuffer, sandboxed: boolean, sourceMapRuntime?: TwingSourceMapRuntime): Promise<TwingTemplate | null>;
    getTemplateSource(name: string): Promise<TwingSource | null>;
    getTest(name: string): TwingTest | null;
    getTraits(): Promise<TwingTemplateBlockMap>;
    hasBlock(name: string, context: TwingContext<any, any>, outputBuffer: TwingOutputBuffer, blocks: TwingTemplateBlockMap, sandboxed: boolean, sourceMapRuntime?: TwingSourceMapRuntime): Promise<boolean>;
    hasMacro(name: string): Promise<boolean>;
    /**
     * @param index
     *
     * @throws {TwingTemplateLoadingError} When no embedded template exists for the passed index.
     */
    loadEmbeddedTemplate(index: number): Promise<TwingTemplate>;
    /**
     * @param identifier
     *
     * @throws {TwingTemplateLoadingError} When no embedded template exists for the passed identifier.
     */
    loadTemplate(identifier: TwingTemplate | string | Array<TwingTemplate | null>): Promise<TwingTemplate>;
    render(context: Record<string, any>, options?: {
        outputBuffer?: TwingOutputBuffer;
        sandboxed?: boolean;
        sourceMapRuntime?: TwingSourceMapRuntime;
    }): Promise<string>;
    renderBlock(name: string, context: TwingContext<any, any>, outputBuffer: TwingOutputBuffer, blocks: TwingTemplateBlockMap, useBlocks: boolean, sandboxed: boolean, sourceMapRuntime?: TwingSourceMapRuntime): Promise<string>;
    renderParentBlock(name: string, context: TwingContext<any, any>, outputBuffer: TwingOutputBuffer, sandboxed: boolean, sourceMapRuntime?: TwingSourceMapRuntime): Promise<string>;
    /**
     * Tries to load templates consecutively from an array.
     *
     * Similar to loadTemplate() but it also accepts instances of TwingTemplate and an array of templates where each is tried to be loaded.
     *
     * @param names A template or an array of templates to try consecutively
     */
    resolveTemplate(names: Array<string | TwingTemplate | null>): Promise<TwingTemplate>;
}
export declare const createTemplate: (environment: TwingEnvironment, ast: TwingTemplateNode) => TwingTemplate;
