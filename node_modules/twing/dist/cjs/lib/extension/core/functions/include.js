"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.include = void 0;
const iterator_to_map_1 = require("../../../helpers/iterator-to-map");
const merge_iterables_1 = require("../../../helpers/merge-iterables");
const is_traversable_1 = require("../../../helpers/is-traversable");
const runtime_1 = require("../../../error/runtime");
const is_plain_object_1 = require("../../../helpers/is-plain-object");
const context_1 = require("../../../context");
const markup_1 = require("../../../markup");
/**
 * Renders a template.
 *
 * @param executionContext
 * @param templates The template to render or an array of templates to try consecutively
 * @param variables The variables to pass to the template
 * @param withContext
 * @param ignoreMissing Whether to ignore missing templates or not
 * @param sandboxed
 *
 * @returns {Promise<TwingMarkup>} The rendered template
 */
const include = (executionContext, templates, variables, withContext, ignoreMissing, sandboxed) => {
    const { template, charset, context, outputBuffer, sourceMapRuntime } = executionContext;
    const from = template.name;
    if (!(0, is_plain_object_1.isPlainObject)(variables) && !(0, is_traversable_1.isTraversable)(variables)) {
        const isVariablesNullOrUndefined = variables === null || variables === undefined;
        return Promise.reject((0, runtime_1.createRuntimeError)(`Variables passed to the "include" function or tag must be iterable, got "${!isVariablesNullOrUndefined ? typeof variables : variables}".`, undefined, from));
    }
    variables = (0, iterator_to_map_1.iteratorToMap)(variables);
    if (withContext) {
        variables = (0, merge_iterables_1.mergeIterables)(context, variables);
    }
    if (!Array.isArray(templates)) {
        templates = [templates];
    }
    const resolveTemplate = (templates) => {
        return template.resolveTemplate(templates)
            .catch((error) => {
            if (!ignoreMissing) {
                throw error;
            }
            else {
                return null;
            }
        });
    };
    return resolveTemplate(templates)
        .then((template) => {
        outputBuffer.start();
        if (template) {
            return template.render((0, context_1.createContext)(variables), {
                outputBuffer,
                sandboxed,
                sourceMapRuntime: sourceMapRuntime || undefined
            });
        }
        else {
            return Promise.resolve('');
        }
    })
        .then(() => {
        const result = outputBuffer.getAndClean();
        return (0, markup_1.createMarkup)(result, charset);
    });
};
exports.include = include;
