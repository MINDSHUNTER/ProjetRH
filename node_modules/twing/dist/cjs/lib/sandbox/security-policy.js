"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSandboxSecurityPolicy = void 0;
const security_not_allowed_filter_error_1 = require("./security-not-allowed-filter-error");
const security_not_allowed_tag_error_1 = require("./security-not-allowed-tag-error");
const security_not_allowed_function_error_1 = require("./security-not-allowed-function-error");
const security_not_allowed_property_error_1 = require("./security-not-allowed-property-error");
const security_not_allowed_method_error_1 = require("./security-not-allowed-method-error");
const markup_1 = require("../markup");
const createSandboxSecurityPolicy = (clearances) => {
    const allowedTags = (clearances === null || clearances === void 0 ? void 0 : clearances.allowedTags) || [];
    const allowedFilters = (clearances === null || clearances === void 0 ? void 0 : clearances.allowedFilters) || [];
    const allowedMethods = (clearances === null || clearances === void 0 ? void 0 : clearances.allowedMethods) || new Map();
    const allowedProperties = (clearances === null || clearances === void 0 ? void 0 : clearances.allowedProperties) || new Map();
    const allowedFunctions = (clearances === null || clearances === void 0 ? void 0 : clearances.allowedFunctions) || [];
    const policy = {
        checkMethodAllowed: (candidate, method) => {
            if ((0, markup_1.isAMarkup)(candidate)) {
                return;
            }
            let allowed = false;
            for (const [constructorName, methods] of allowedMethods) {
                if (candidate instanceof constructorName) {
                    allowed = methods.includes(method);
                    break;
                }
            }
            if (!allowed) {
                const constructorName = candidate.constructor.name || '(anonymous)';
                throw (0, security_not_allowed_method_error_1.createSandboxSecurityNotAllowedMethodError)(`Calling "${method}" method on an instance of ${constructorName} is not allowed.`);
            }
        },
        checkPropertyAllowed: (candidate, property) => {
            let allowed = false;
            for (let [objectConstructor, properties] of allowedProperties) {
                if (candidate instanceof objectConstructor) {
                    allowed = properties.includes(property);
                    break;
                }
            }
            if (!allowed) {
                const constructorName = candidate.constructor.name || '(anonymous)';
                throw (0, security_not_allowed_property_error_1.createSandboxSecurityNotAllowedPropertyError)(`Calling "${property}" property on an instance of ${constructorName} is not allowed.`);
            }
        },
        checkSecurity: (tags, filters, functions) => {
            for (const tag of tags) {
                if (!allowedTags.includes(tag)) {
                    throw (0, security_not_allowed_tag_error_1.createSandboxSecurityNotAllowedTagError)(`Tag "${tag}" is not allowed.`, tag);
                }
            }
            for (const filterName of filters) {
                if (!allowedFilters.includes(filterName)) {
                    throw (0, security_not_allowed_filter_error_1.createSandboxSecurityNotAllowedFilterError)(`Filter "${filterName}" is not allowed.`, filterName);
                }
            }
            for (const function_ of functions) {
                if (!allowedFunctions.includes(function_)) {
                    throw (0, security_not_allowed_function_error_1.createSandboxSecurityNotAllowedFunctionError)(`Function "${function_}" is not allowed.`, function_);
                }
            }
        }
    };
    return policy;
};
exports.createSandboxSecurityPolicy = createSandboxSecurityPolicy;
