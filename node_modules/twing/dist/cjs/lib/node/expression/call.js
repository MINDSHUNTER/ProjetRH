"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBaseCallNode = void 0;
const expression_1 = require("../expression");
const constant_1 = require("./constant");
const array_1 = require("./array");
const runtime_1 = require("../../error/runtime");
const traceable_method_1 = require("../../helpers/traceable-method");
const array_merge = require('locutus/php/array/array_merge');
const snakeCase = require('snake-case');
const createBaseCallNode = (type, operatorName, operand, callArguments, line, column) => {
    let children = {
        arguments: callArguments
    };
    if (operand !== null) {
        children.operand = operand;
    }
    const baseNode = (0, expression_1.createBaseExpressionNode)(type, {
        operatorName
    }, children, line, column);
    const normalizeName = (name) => {
        return snakeCase(name).toLowerCase();
    };
    const getArguments = (argumentsNode, acceptedArguments, isVariadic) => {
        const callType = type;
        const callName = baseNode.attributes.operatorName;
        const parameters = new Map();
        let named = false;
        const keyPairs = (0, array_1.getKeyValuePairs)(argumentsNode);
        for (let { key, value } of keyPairs) {
            let name = key.attributes.value;
            if (typeof name === "string") {
                named = true;
                name = normalizeName(name);
            }
            else if (named) {
                throw (0, runtime_1.createRuntimeError)(`Positional arguments cannot be used after named arguments for ${callType} "${callName}".`, baseNode);
            }
            parameters.set(name, {
                key,
                value
            });
        }
        const callableParameters = acceptedArguments;
        const names = [];
        let optionalArguments = [];
        let arguments_ = [];
        let position = 0;
        for (const callableParameter of callableParameters) {
            const name = '' + normalizeName(callableParameter.name);
            names.push(name);
            const parameter = parameters.get(name);
            if (parameter) {
                if (parameters.has(position)) {
                    throw (0, runtime_1.createRuntimeError)(`Argument "${name}" is defined twice for ${callType} "${callName}".`, baseNode);
                }
                arguments_ = array_merge(arguments_, optionalArguments);
                arguments_.push(parameter.value);
                parameters.delete(name);
                optionalArguments = [];
            }
            else {
                const parameter = parameters.get(position);
                if (parameter) {
                    arguments_ = array_merge(arguments_, optionalArguments);
                    arguments_.push(parameter.value);
                    parameters.delete(position);
                    optionalArguments = [];
                    ++position;
                }
                else if (callableParameter.defaultValue !== undefined) {
                    arguments_.push((0, constant_1.createConstantNode)(callableParameter.defaultValue, line, column));
                }
                else {
                    throw (0, runtime_1.createRuntimeError)(`Value for argument "${name}" is required for ${callType} "${callName}".`, baseNode);
                }
            }
        }
        if (isVariadic) {
            const resolvedKeys = [];
            const arbitraryArguments = [];
            for (const [key, value] of parameters) {
                arbitraryArguments.push(value.value);
                resolvedKeys.push(key);
            }
            for (const key of resolvedKeys) {
                parameters.delete(key);
            }
            if (arbitraryArguments.length) {
                arguments_ = array_merge(arguments_, optionalArguments);
                arguments_.push(...arbitraryArguments);
            }
        }
        if (parameters.size > 0) {
            const unknownParameter = [...parameters.values()][0];
            throw (0, runtime_1.createRuntimeError)(`Unknown argument${parameters.size > 1 ? 's' : ''} "${[...parameters.keys()].join('", "')}" for ${callType} "${callName}(${names.join(', ')})".`, unknownParameter.key);
        }
        return arguments_;
    };
    const baseCallNode = Object.assign(Object.assign({}, baseNode), { execute: async (executionContext) => {
            const { template } = executionContext;
            const { operatorName } = baseCallNode.attributes;
            let callableWrapper;
            switch (type) {
                case "filter":
                    callableWrapper = template.getFilter(operatorName);
                    break;
                case "function":
                    callableWrapper = template.getFunction(operatorName);
                    break;
                // for some reason, using `case "test"` makes the compiler assume that callableWrapper is used
                // before it is assigned a value; this is probably a bug of the compiler
                default:
                    callableWrapper = template.getTest(operatorName);
                    break;
            }
            if (callableWrapper === null) {
                throw (0, runtime_1.createRuntimeError)(`Unknown ${type} "${operatorName}".`, baseNode);
            }
            const { operand, arguments: callArguments } = baseCallNode.children;
            const argumentNodes = getArguments(callArguments, callableWrapper.acceptedArguments, callableWrapper.isVariadic);
            const actualArguments = [];
            actualArguments.push(...callableWrapper.nativeArguments);
            if (operand) {
                actualArguments.push(await operand.execute(executionContext));
            }
            const providedArguments = await Promise.all([
                ...argumentNodes.map((node) => node.execute(executionContext))
            ]);
            actualArguments.push(...providedArguments);
            const traceableCallable = (0, traceable_method_1.getTraceableMethod)(callableWrapper.callable, baseCallNode.line, baseCallNode.column, template.name);
            return traceableCallable(executionContext, ...actualArguments);
        } });
    return baseCallNode;
};
exports.createBaseCallNode = createBaseCallNode;
