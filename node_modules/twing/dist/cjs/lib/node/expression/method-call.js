"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cloneMethodCallNode = exports.createMethodCallNode = void 0;
const expression_1 = require("../expression");
const array_1 = require("./array");
const runtime_1 = require("../../error/runtime");
const createMethodCallNode = (operand, methodName, methodArguments, line, column) => {
    const baseNode = (0, expression_1.createBaseExpressionNode)("method_call", {
        methodName,
        shouldTestExistence: false
    }, {
        operand,
        arguments: methodArguments
    }, line, column);
    const methodCallNode = Object.assign(Object.assign({}, baseNode), { execute: async (executionContext) => {
            const { template, context, outputBuffer, aliases, sandboxed, sourceMapRuntime } = executionContext;
            const { methodName, shouldTestExistence } = baseNode.attributes;
            const { operand, arguments: methodArguments } = baseNode.children;
            if (shouldTestExistence) {
                return aliases.get(operand.attributes.name).hasMacro(methodName);
            }
            else {
                const keyValuePairs = (0, array_1.getKeyValuePairs)(methodArguments);
                const macroArguments = [];
                for (const { value: valueNode } of keyValuePairs) {
                    const value = await valueNode.execute(executionContext);
                    macroArguments.push(value);
                }
                // by nature, the alias exists - the parser only creates a method call node when the name _is_ an alias.
                const macroTemplate = aliases.get(operand.attributes.name);
                const getHandler = (template) => {
                    const macroHandler = template.macroHandlers.get(methodName);
                    if (macroHandler) {
                        return Promise.resolve(macroHandler);
                    }
                    else {
                        return template.getParent(context, outputBuffer, sandboxed)
                            .then((parent) => {
                            if (parent) {
                                return getHandler(parent);
                            }
                            else {
                                return null;
                            }
                        });
                    }
                };
                return getHandler(macroTemplate)
                    .then((handler) => {
                    if (handler) {
                        return handler(outputBuffer, sandboxed, sourceMapRuntime, ...macroArguments);
                    }
                    else {
                        throw (0, runtime_1.createRuntimeError)(`Macro "${methodName}" is not defined in template "${macroTemplate.name}".`, methodCallNode, template.name);
                    }
                });
            }
        } });
    return methodCallNode;
};
exports.createMethodCallNode = createMethodCallNode;
const cloneMethodCallNode = (methodCallNode) => {
    return (0, exports.createMethodCallNode)(methodCallNode.children.operand, methodCallNode.attributes.methodName, methodCallNode.children.arguments, methodCallNode.line, methodCallNode.column);
};
exports.cloneMethodCallNode = cloneMethodCallNode;
