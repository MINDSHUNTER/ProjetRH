"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cloneBlockReferenceExpressionNode = exports.createBlockFunctionNode = void 0;
const expression_1 = require("../expression");
const traceable_method_1 = require("../../helpers/traceable-method");
const createBlockFunctionNode = (name, template, line, column, tag) => {
    const children = {
        name
    };
    if (template) {
        children.template = template;
    }
    const baseNode = (0, expression_1.createBaseExpressionNode)("block_function", {
        shouldTestExistence: false
    }, children, line, column, tag);
    const blockFunctionNode = Object.assign(Object.assign({}, baseNode), { execute: async (executionContext) => {
            const { template, context, outputBuffer, blocks, sandboxed, sourceMapRuntime } = executionContext;
            const { template: templateNode, name: blockNameNode } = blockFunctionNode.children;
            const blockName = await blockNameNode.execute(executionContext);
            let resolveTemplate;
            if (templateNode) {
                const templateName = await templateNode.execute(executionContext);
                const loadTemplate = (0, traceable_method_1.getTraceableMethod)(template.loadTemplate, templateNode.line, templateNode.column, template.name);
                resolveTemplate = loadTemplate(templateName);
            }
            else {
                resolveTemplate = Promise.resolve(template);
            }
            return resolveTemplate
                .then((executionContextOfTheBlock) => {
                if (blockFunctionNode.attributes.shouldTestExistence) {
                    const hasBlock = (0, traceable_method_1.getTraceableMethod)(executionContextOfTheBlock.hasBlock, blockFunctionNode.line, blockFunctionNode.column, template.name);
                    return hasBlock(blockName, context.clone(), outputBuffer, blocks, sandboxed);
                }
                else {
                    const renderBlock = (0, traceable_method_1.getTraceableMethod)(executionContextOfTheBlock.renderBlock, blockFunctionNode.line, blockFunctionNode.column, template.name);
                    if (templateNode) {
                        return renderBlock(blockName, context.clone(), outputBuffer, new Map(), false, sandboxed, sourceMapRuntime);
                    }
                    else {
                        return renderBlock(blockName, context.clone(), outputBuffer, blocks, true, sandboxed, sourceMapRuntime);
                    }
                }
            });
        } });
    return blockFunctionNode;
};
exports.createBlockFunctionNode = createBlockFunctionNode;
const cloneBlockReferenceExpressionNode = (blockFunctionNode) => {
    return (0, exports.createBlockFunctionNode)(blockFunctionNode.children.name, blockFunctionNode.children.template || null, blockFunctionNode.line, blockFunctionNode.column);
};
exports.cloneBlockReferenceExpressionNode = cloneBlockReferenceExpressionNode;
