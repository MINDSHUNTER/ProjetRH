"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTemplate = void 0;
const context_1 = require("./context");
const output_buffer_1 = require("./output-buffer");
const merge_iterables_1 = require("./helpers/merge-iterables");
const runtime_1 = require("./error/runtime");
const node_1 = require("./node");
const markup_1 = require("./markup");
const loader_1 = require("./error/loader");
const clone_map_1 = require("./helpers/clone-map");
const body_1 = require("./node/body");
const array_1 = require("./node/expression/array");
const iterator_to_map_1 = require("./helpers/iterator-to-map");
const source_1 = require("./source");
const get_filter_1 = require("./helpers/get-filter");
const get_test_1 = require("./helpers/get-test");
const get_function_1 = require("./helpers/get-function");
const createHash = require("create-hash");
const traceable_method_1 = require("./helpers/traceable-method");
const createTemplate = (environment, ast) => {
    const { charset, dateFormat, dateIntervalFormat, isStrictVariables, numberFormat, timezone } = environment;
    // blocks
    const blockHandlers = new Map();
    let blocks = null;
    const { blocks: blockNodes } = ast.children;
    for (const [name, blockNode] of (0, node_1.getChildren)(blockNodes)) {
        const blockHandler = (context, outputBuffer, blocks, sandboxed, sourceMapRuntime) => {
            const aliases = template.aliases.clone();
            return blockNode.children.body.execute({
                aliases,
                blocks,
                charset,
                context,
                dateFormat,
                dateIntervalFormat,
                globals: environment.globals,
                isStrictVariables,
                numberFormat,
                outputBuffer,
                sandboxed,
                sourceMapRuntime,
                template,
                timezone
            });
        };
        blockHandlers.set(name, blockHandler);
    }
    // macros
    const macroHandlers = new Map();
    const { macros: macrosNode } = ast.children;
    for (const [name, macroNode] of Object.entries(macrosNode.children)) {
        const macroHandler = async (outputBuffer, sandboxed, sourceMapRuntime, ...args) => {
            const { body, arguments: macroArguments } = macroNode.children;
            const keyValuePairs = (0, array_1.getKeyValuePairs)(macroArguments);
            const aliases = template.aliases.clone();
            const localVariables = new Map();
            for (const { key: keyNode, value: defaultValueNode } of keyValuePairs) {
                const key = keyNode.attributes.value;
                const defaultValue = await defaultValueNode.execute({
                    aliases,
                    blocks: new Map(),
                    charset,
                    context: (0, context_1.createContext)(),
                    dateFormat,
                    dateIntervalFormat,
                    globals: environment.globals,
                    isStrictVariables,
                    numberFormat,
                    outputBuffer,
                    sandboxed,
                    sourceMapRuntime,
                    template,
                    timezone
                });
                let value = args.shift();
                if (value === undefined) {
                    value = defaultValue;
                }
                localVariables.set(key, value);
            }
            localVariables.set('varargs', args);
            const context = (0, context_1.createContext)(localVariables);
            const blocks = new Map();
            outputBuffer.start();
            return await body.execute({
                aliases,
                blocks,
                charset,
                context,
                dateFormat,
                dateIntervalFormat,
                globals: environment.globals,
                isStrictVariables,
                numberFormat,
                outputBuffer,
                sandboxed,
                sourceMapRuntime,
                template,
                timezone
            })
                .then(() => {
                const content = outputBuffer.getContents();
                return (0, markup_1.createMarkup)(content, environment.charset);
            })
                .finally(() => {
                outputBuffer.endAndClean();
            });
        };
        macroHandlers.set(name, macroHandler);
    }
    // traits
    let traits = null;
    // embedded templates
    const embeddedTemplates = new Map();
    for (const embeddedTemplate of ast.embeddedTemplates) {
        embeddedTemplates.set(embeddedTemplate.attributes.index, embeddedTemplate);
    }
    // parent
    let parent = null;
    const displayParentBlock = (name, context, outputBuffer, blocks, sandboxed, sourceMapRuntime) => {
        return template.getTraits()
            .then((traits) => {
            const trait = traits.get(name);
            if (trait) {
                const [blockTemplate, blockName] = trait;
                return blockTemplate.displayBlock(blockName, context, outputBuffer, blocks, false, sandboxed, sourceMapRuntime);
            }
            else {
                return template.getParent(context, outputBuffer, sandboxed, sourceMapRuntime)
                    .then((parent) => {
                    if (parent !== null) {
                        return parent.displayBlock(name, context, outputBuffer, blocks, false, sandboxed, sourceMapRuntime);
                    }
                    else {
                        throw (0, runtime_1.createRuntimeError)(`The template has no parent and no traits defining the "${name}" block.`, undefined, template.name);
                    }
                });
            }
        });
    };
    // A template can be used as a trait if:
    //   * it has no parent
    //   * it has no macros
    //   * it has no body
    //
    // Put another way, a template can be used as a trait if it
    // only contains blocks and use statements.
    const { parent: parentNode, macros, body } = ast.children;
    const { line, column } = ast;
    let canBeUsedAsATrait = (parentNode === undefined) && ((0, node_1.getChildrenCount)(macros) === 0);
    if (canBeUsedAsATrait) {
        let node = body.children.content;
        if ((0, node_1.getChildrenCount)(node) === 0) {
            node = (0, body_1.createBodyNode)(node, line, column);
        }
        for (const [, child] of Object.entries(node.children)) {
            if ((0, node_1.getChildrenCount)(child) === 0) {
                continue;
            }
            canBeUsedAsATrait = false;
            break;
        }
    }
    const template = {
        get aliases() {
            return aliases;
        },
        get blockHandlers() {
            return blockHandlers;
        },
        get canBeUsedAsATrait() {
            return canBeUsedAsATrait;
        },
        get macroHandlers() {
            return macroHandlers;
        },
        get name() {
            return template.source.name;
        },
        get source() {
            return ast.attributes.source;
        },
        checkMethodAllowed: environment.sandboxPolicy.checkMethodAllowed,
        checkPropertyAllowed: environment.sandboxPolicy.checkPropertyAllowed,
        checkSecurity: environment.sandboxPolicy.checkSecurity,
        createTemplateFromString: (code, name) => {
            const hash = createHash("sha256").update(code).digest("hex").toString();
            if (name !== null) {
                name = `${name} (string template ${hash})`;
            }
            else {
                name = `__string_template__${hash}`;
            }
            const ast = environment.parse(environment.tokenize((0, source_1.createSource)(name, code)));
            const template = (0, exports.createTemplate)(environment, ast);
            return Promise.resolve(template);
        },
        displayBlock: (name, context, outputBuffer, blocks, useBlocks, sandboxed, sourceMapRuntime) => {
            return template.getBlocks()
                .then((ownBlocks) => {
                let blockHandler;
                let block;
                if (useBlocks && (block = blocks.get(name)) !== undefined) {
                    const [blockTemplate, blockName] = block;
                    blockHandler = blockTemplate.blockHandlers.get(blockName);
                }
                else if ((block = ownBlocks.get(name)) !== undefined) {
                    const [blockTemplate, blockName] = block;
                    blockHandler = blockTemplate.blockHandlers.get(blockName);
                }
                if (blockHandler) {
                    return blockHandler(context, outputBuffer, blocks, sandboxed, sourceMapRuntime);
                }
                else {
                    return template.getParent(context, outputBuffer, sandboxed, sourceMapRuntime).then((parent) => {
                        if (parent) {
                            return parent.displayBlock(name, context, outputBuffer, (0, merge_iterables_1.mergeIterables)(ownBlocks, blocks), false, sandboxed, sourceMapRuntime);
                        }
                        else {
                            const block = blocks.get(name);
                            if (block) {
                                const [blockTemplate] = block;
                                throw (0, runtime_1.createRuntimeError)(`Block "${name}" should not call parent() in "${blockTemplate.name}" as the block does not exist in the parent template "${template.name}".`, undefined, blockTemplate.name);
                            }
                            else {
                                throw (0, runtime_1.createRuntimeError)(`Block "${name}" on template "${template.name}" does not exist.`, undefined, template.name);
                            }
                        }
                    });
                }
            });
        },
        escape: (value, strategy, charset) => {
            if (typeof value === "boolean") {
                return Promise.resolve(value);
            }
            if ((0, markup_1.isAMarkup)(value)) {
                return Promise.resolve(value);
            }
            let result;
            if ((value === null) || (value === undefined)) {
                result = '';
            }
            else {
                const strategyHandler = environment.escapingStrategyHandlers[strategy];
                if (strategyHandler === undefined) {
                    return Promise.reject((0, runtime_1.createRuntimeError)(`Invalid escaping strategy "${strategy}" (valid ones: ${Object.keys(environment.escapingStrategyHandlers).sort().join(', ')}).`));
                }
                result = strategyHandler(value.toString(), charset || environment.charset, template.name);
            }
            return Promise.resolve(result);
        },
        execute: async (context, outputBuffer, childBlocks, options) => {
            const aliases = template.aliases.clone();
            const sandboxed = (options === null || options === void 0 ? void 0 : options.sandboxed) || false;
            const sourceMapRuntime = options === null || options === void 0 ? void 0 : options.sourceMapRuntime;
            return Promise.all([
                template.getParent(context, outputBuffer, sandboxed, sourceMapRuntime),
                template.getBlocks()
            ]).then(([parent, ownBlocks]) => {
                const blocks = (0, merge_iterables_1.mergeIterables)(ownBlocks, childBlocks);
                return ast.execute({
                    aliases,
                    blocks,
                    charset,
                    context,
                    dateFormat,
                    dateIntervalFormat,
                    globals: environment.globals,
                    isStrictVariables,
                    numberFormat,
                    outputBuffer,
                    sandboxed,
                    sourceMapRuntime,
                    template,
                    timezone
                }).then(() => {
                    if (parent) {
                        return parent.execute(context, outputBuffer, blocks, {
                            sandboxed,
                            sourceMapRuntime
                        });
                    }
                });
            }).catch((error) => {
                if (!error.source) {
                    error.source = template.name;
                }
                if ((0, loader_1.isATemplateLoadingError)(error)) {
                    error = (0, runtime_1.createRuntimeError)(error.rootMessage, error.location, error.source, error);
                }
                throw error;
            });
        },
        getBlocks: () => {
            if (blocks) {
                return Promise.resolve(blocks);
            }
            else {
                return template.getTraits()
                    .then((traits) => {
                    blocks = (0, merge_iterables_1.mergeIterables)(traits, new Map([...blockHandlers.keys()].map((key) => {
                        return [key, [template, key]];
                    })));
                    return blocks;
                });
            }
        },
        getFilter: (name) => {
            return (0, get_filter_1.getFilter)(environment.filters, name);
        },
        getFunction: (name) => {
            return (0, get_function_1.getFunction)(environment.functions, name);
        },
        getParent: async (context, outputBuffer, sandboxed, sourceMapRuntime) => {
            if (parent !== null) {
                return Promise.resolve(parent);
            }
            const parentNode = ast.children.parent;
            if (parentNode) {
                return template.getBlocks()
                    .then(async (blocks) => {
                    const parentName = await parentNode.execute({
                        aliases: (0, context_1.createContext)(),
                        blocks,
                        charset,
                        context,
                        dateFormat,
                        dateIntervalFormat,
                        globals: environment.globals,
                        isStrictVariables,
                        numberFormat,
                        outputBuffer,
                        sandboxed,
                        sourceMapRuntime,
                        template,
                        timezone
                    });
                    const loadTemplate = (0, traceable_method_1.getTraceableMethod)(template.loadTemplate, parentNode.line, parentNode.column, template.name);
                    const loadedParent = await loadTemplate(parentName);
                    if (parentNode.type === "constant") {
                        parent = loadedParent;
                    }
                    return loadedParent;
                });
            }
            else {
                return Promise.resolve(null);
            }
        },
        getTemplateSource: (name) => {
            return environment.loader.getSource(name, template.name);
        },
        getTest: (name) => {
            return (0, get_test_1.getTest)(environment.tests, name);
        },
        getTraits: async () => {
            if (traits === null) {
                traits = new Map();
                const { traits: traitsNode } = ast.children;
                for (const [, traitNode] of (0, node_1.getChildren)(traitsNode)) {
                    const { template: templateNameNode, targets } = traitNode.children;
                    const templateName = templateNameNode.attributes.value;
                    const loadTemplate = (0, traceable_method_1.getTraceableMethod)(template.loadTemplate, templateNameNode.line, templateNameNode.column, template.name);
                    const traitExecutionContext = await loadTemplate(templateName);
                    if (!traitExecutionContext.canBeUsedAsATrait) {
                        throw (0, runtime_1.createRuntimeError)(`Template ${templateName} cannot be used as a trait.`, templateNameNode, template.name);
                    }
                    const traitBlocks = (0, clone_map_1.cloneMap)(await traitExecutionContext.getBlocks());
                    for (const [key, target] of (0, node_1.getChildren)(targets)) {
                        const traitBlock = traitBlocks.get(key);
                        if (!traitBlock) {
                            throw (0, runtime_1.createRuntimeError)(`Block "${key}" is not defined in trait "${templateName}".`, templateNameNode, template.name);
                        }
                        const targetValue = target.attributes.value;
                        traitBlocks.set(targetValue, traitBlock);
                        traitBlocks.delete(key);
                    }
                    traits = (0, merge_iterables_1.mergeIterables)(traits, traitBlocks);
                }
            }
            return Promise.resolve(traits);
        },
        hasBlock: (name, context, outputBuffer, blocks, sandboxed, sourceMapRuntime) => {
            if (blocks.has(name)) {
                return Promise.resolve(true);
            }
            else {
                return template.getBlocks()
                    .then((blocks) => {
                    if (blocks.has(name)) {
                        return Promise.resolve(true);
                    }
                    else {
                        return template.getParent(context, outputBuffer, sandboxed, sourceMapRuntime)
                            .then((parent) => {
                            if (parent) {
                                return parent.hasBlock(name, context, outputBuffer, blocks, sandboxed, sourceMapRuntime);
                            }
                            else {
                                return false;
                            }
                        });
                    }
                });
            }
        },
        hasMacro: (name) => {
            // @see https://github.com/twigphp/Twig/issues/3174 as to why we don't check macro existence in parents
            return Promise.resolve(template.macroHandlers.has(name));
        },
        loadEmbeddedTemplate: (index) => {
            const ast = embeddedTemplates.get(index);
            if (ast === undefined) {
                return Promise.reject((0, loader_1.createTemplateLoadingError)([`embedded#${index}`]));
            }
            return Promise.resolve((0, exports.createTemplate)(environment, ast));
        },
        loadTemplate: (identifier) => {
            let promise;
            if (typeof identifier === "string") {
                promise = environment.loadTemplate(identifier, template.name);
            }
            else if (Array.isArray(identifier)) {
                promise = template.resolveTemplate(identifier);
            }
            else {
                promise = Promise.resolve(identifier);
            }
            return promise;
        },
        render: (context, options) => {
            const actualOutputBuffer = (options === null || options === void 0 ? void 0 : options.outputBuffer) || (0, output_buffer_1.createOutputBuffer)();
            actualOutputBuffer.start();
            return template.execute((0, context_1.createContext)((0, iterator_to_map_1.iteratorToMap)(context)), actualOutputBuffer, new Map(), {
                sandboxed: options === null || options === void 0 ? void 0 : options.sandboxed,
                sourceMapRuntime: options === null || options === void 0 ? void 0 : options.sourceMapRuntime
            }).then(() => {
                return actualOutputBuffer.getAndFlush();
            });
        },
        renderBlock: (name, context, outputBuffer, blocks, useBlocks, sandboxed, sourceMapRuntime) => {
            outputBuffer.start();
            return template.displayBlock(name, context, outputBuffer, blocks, useBlocks, sandboxed, sourceMapRuntime).then(() => {
                return outputBuffer.getAndClean();
            });
        },
        renderParentBlock: (name, context, outputBuffer, sandboxed, sourceMapRuntime) => {
            outputBuffer.start();
            return template.getBlocks()
                .then((blocks) => {
                return displayParentBlock(name, context, outputBuffer, blocks, sandboxed, sourceMapRuntime).then(() => {
                    return outputBuffer.getAndClean();
                });
            });
        },
        resolveTemplate: (names) => {
            const loadTemplateAtIndex = (index) => {
                if (index < names.length) {
                    const name = names[index];
                    if (name === null) {
                        return loadTemplateAtIndex(index + 1);
                    }
                    else if (typeof name !== "string") {
                        return Promise.resolve(name);
                    }
                    else {
                        return template.loadTemplate(name)
                            .catch(() => {
                            return loadTemplateAtIndex(index + 1);
                        });
                    }
                }
                else {
                    return Promise.reject((0, loader_1.createTemplateLoadingError)(names.map((name) => {
                        if (name === null) {
                            return '';
                        }
                        return name;
                    }), undefined, template.name));
                }
            };
            return loadTemplateAtIndex(0);
        }
    };
    const aliases = (0, context_1.createContext)();
    aliases.set(`_self`, template);
    return template;
};
exports.createTemplate = createTemplate;
