"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEnvironment = void 0;
const extension_set_1 = require("./extension-set");
const parser_1 = require("./parser");
const html_1 = require("./escaping-stragegy/html");
const css_1 = require("./escaping-stragegy/css");
const js_1 = require("./escaping-stragegy/js");
const url_1 = require("./escaping-stragegy/url");
const html_attribute_1 = require("./escaping-stragegy/html-attribute");
const token_stream_1 = require("./token-stream");
const source_map_runtime_1 = require("./source-map-runtime");
const security_policy_1 = require("./sandbox/security-policy");
const template_1 = require("./template");
const luxon_1 = require("luxon");
const events_1 = require("events");
const loader_1 = require("./error/loader");
const lexer_1 = require("./lexer");
const core_1 = require("./extension/core");
const lib_1 = require("../lib");
const iterator_to_map_1 = require("./helpers/iterator-to-map");
const context_1 = require("./context");
/**
 * Creates an instance of {@link TwingEnvironment} backed by the passed loader.
 *
 * @param loader
 * @param options
 */
const createEnvironment = (loader, options) => {
    const cssEscapingStrategy = (0, css_1.createCssEscapingStrategyHandler)();
    const htmlEscapingStrategy = (0, html_1.createHtmlEscapingStrategyHandler)();
    const htmlAttributeEscapingStrategy = (0, html_attribute_1.createHtmlAttributeEscapingStrategyHandler)();
    const jsEscapingStrategy = (0, js_1.createJsEscapingStrategyHandler)();
    const urlEscapingStrategy = (0, url_1.createUrlEscapingStrategyHandler)();
    const escapingStrategyHandlers = {
        css: cssEscapingStrategy,
        html: htmlEscapingStrategy,
        html_attr: htmlAttributeEscapingStrategy,
        js: jsEscapingStrategy,
        url: urlEscapingStrategy
    };
    const extensionSet = (0, extension_set_1.createExtensionSet)();
    extensionSet.addExtension((0, core_1.createCoreExtension)());
    const shouldAutoReload = (options === null || options === void 0 ? void 0 : options.autoReload) || false;
    const cache = (options === null || options === void 0 ? void 0 : options.cache) || null;
    const charset = (options === null || options === void 0 ? void 0 : options.charset) || 'UTF-8';
    const dateFormat = (options === null || options === void 0 ? void 0 : options.dateFormat) || 'F j, Y H:i';
    const dateIntervalFormat = (options === null || options === void 0 ? void 0 : options.dateIntervalFormat) || '%d days';
    const numberFormat = (options === null || options === void 0 ? void 0 : options.numberFormat) || {
        decimalPoint: '.',
        numberOfDecimals: 0,
        thousandSeparator: ','
    };
    const eventEmitter = new events_1.EventEmitter();
    const sandboxPolicy = (options === null || options === void 0 ? void 0 : options.sandboxPolicy) || (0, security_policy_1.createSandboxSecurityPolicy)();
    const globals = (0, context_1.createContext)((0, iterator_to_map_1.iteratorToMap)((options === null || options === void 0 ? void 0 : options.globals) || {}));
    let isSandboxed = (options === null || options === void 0 ? void 0 : options.sandboxed) ? true : false;
    let lexer;
    let parser;
    const loadedTemplates = new Map();
    const environment = {
        get charset() {
            return charset;
        },
        get dateFormat() {
            return dateFormat;
        },
        get dateIntervalFormat() {
            return dateIntervalFormat;
        },
        get escapingStrategyHandlers() {
            return escapingStrategyHandlers;
        },
        get filters() {
            return extensionSet.filters;
        },
        get functions() {
            return extensionSet.functions;
        },
        get globals() {
            return globals;
        },
        get isStrictVariables() {
            return (options === null || options === void 0 ? void 0 : options.strictVariables) ? true : false;
        },
        get loader() {
            return loader;
        },
        get numberFormat() {
            return numberFormat;
        },
        get sandboxPolicy() {
            return sandboxPolicy;
        },
        get tests() {
            return extensionSet.tests;
        },
        get timezone() {
            return (options === null || options === void 0 ? void 0 : options.timezone) || luxon_1.Settings.defaultZoneName;
        },
        addExtension: extensionSet.addExtension,
        addFilter: extensionSet.addFilter,
        addFunction: extensionSet.addFunction,
        addNodeVisitor: extensionSet.addNodeVisitor,
        addOperator: extensionSet.addOperator,
        addTagHandler: extensionSet.addTagHandler,
        addTest: extensionSet.addTest,
        loadTemplate: async (name, from = null) => {
            eventEmitter.emit('load', name, from);
            let templateFqn = await loader.resolve(name, from) || name;
            let loadedTemplate = loadedTemplates.get(templateFqn);
            if (loadedTemplate) {
                return Promise.resolve(loadedTemplate);
            }
            else {
                const timestamp = cache ? await cache.getTimestamp(templateFqn) : 0;
                const getAstFromCache = async () => {
                    if (cache === null) {
                        return Promise.resolve(null);
                    }
                    let content;
                    /**
                     * When auto-reload is disabled, we always challenge the cache
                     * When auto-reload is enabled, we challenge the cache only if the template is considered as fresh by the loader
                     */
                    if (shouldAutoReload) {
                        const isFresh = await loader.isFresh(name, timestamp, from);
                        if (isFresh) {
                            content = await cache.load(name);
                        }
                        else {
                            content = null;
                        }
                    }
                    else {
                        content = await cache.load(name);
                    }
                    return content;
                };
                const getAstFromLoader = async () => {
                    const source = await loader.getSource(name, from);
                    if (source === null) {
                        return null;
                    }
                    const ast = environment.parse(environment.tokenize(source));
                    if (cache !== null) {
                        await cache.write(name, ast);
                    }
                    return ast;
                };
                let ast = await getAstFromCache();
                if (ast === null) {
                    ast = await getAstFromLoader();
                }
                if (ast === null) {
                    throw (0, loader_1.createTemplateLoadingError)([name]);
                }
                const template = (0, template_1.createTemplate)(environment, ast);
                loadedTemplates.set(templateFqn, template);
                return template;
            }
        },
        on: (eventName, listener) => {
            eventEmitter.on(eventName, listener);
        },
        registerEscapingStrategy: (handler, name) => {
            escapingStrategyHandlers[name] = handler;
        },
        parse: (stream, parserOptions) => {
            if (!parser) {
                const visitors = extensionSet.nodeVisitors;
                if (options === null || options === void 0 ? void 0 : options.autoEscapingStrategy) {
                    const strategy = options.autoEscapingStrategy;
                    visitors.unshift({
                        enterNode: (node) => {
                            return node;
                        },
                        leaveNode: (node) => {
                            if (node.type === "template") {
                                const autoEscapeNode = (0, lib_1.createAutoEscapeNode)(strategy, node.children.body.children.content, node.line, node.column, 'foo');
                                node.children.body.children.content = autoEscapeNode;
                            }
                            return node;
                        }
                    });
                }
                parser = (0, parser_1.createParser)(extensionSet.unaryOperators, extensionSet.binaryOperators, extensionSet.tagHandlers, extensionSet.nodeVisitors, extensionSet.filters, extensionSet.functions, extensionSet.tests, parserOptions || (options === null || options === void 0 ? void 0 : options.parserOptions) || {
                    strict: true,
                    level: 3
                });
            }
            try {
                return parser.parse(stream);
            }
            catch (error) {
                const source = stream.source;
                if (!error.source) {
                    error.source = source.name;
                }
                throw error;
            }
        },
        render: (name, context) => {
            return environment.loadTemplate(name)
                .then((template) => {
                return template.render(context, {
                    sandboxed: isSandboxed
                });
            });
        },
        renderWithSourceMap: (name, context) => {
            const sourceMapRuntime = (0, source_map_runtime_1.createSourceMapRuntime)();
            return environment.loadTemplate(name)
                .then((template) => {
                return template.render(context, {
                    sandboxed: isSandboxed,
                    sourceMapRuntime
                });
            })
                .then((data) => {
                const { sourceMap } = sourceMapRuntime;
                return {
                    data,
                    sourceMap
                };
            });
        },
        tokenize: (source) => {
            var _a;
            const level = ((_a = options === null || options === void 0 ? void 0 : options.parserOptions) === null || _a === void 0 ? void 0 : _a.level) || 3;
            if (!lexer) {
                lexer = (0, lexer_1.createLexer)(level, extensionSet.binaryOperators, extensionSet.unaryOperators);
            }
            const stream = lexer.tokenizeSource(source);
            return (0, token_stream_1.createTokenStream)(stream.toAst(), stream.source);
        }
    };
    return environment;
};
exports.createEnvironment = createEnvironment;
